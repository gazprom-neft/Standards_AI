# Требования к цифровым продуктам с искусственным интеллектом

## Аннотация

Цифровой проект с использованием искусственного интеллекта (ПИИ) – программный продукт, ключевой функционал которого построен на технологиях ИИ. В общем случае такой продукт состоит из набора математических моделей и программной логики, связывающей их работу. Помимо этого в цифровой продукт ИИ входит программная оболочка, которая обеспечивает работу математического ядра, сопрягает его с другими приложениями, предоставляет доступ к продуктивным и историческим данным, а также реализует интерфейсы взаимодействия с пользователями и устройствами. С точки зрения практического применения, цифровой продукт ИИ может выступать в качестве экспертной системы для помощи человеку в принятии решений или же автоматизировать обработку технологической информации, многократно снижая трудозатраты ответственного специалиста.

Текущий документ содержит информацию об основных требованиях к разработке, оформлению и документированию цифрового продукта ИИ. Во многих случаях это неразрывно связано с функциональными и техническими требованиями, предъявляемыми к конечному продукту. Тем не менее, важно подчеркнуть, что последний вопрос является в первую очередь прерогативой технического задания (ТЗ), где он должен всецело освещаться. Поэтому, хотя в разделах ниже и будут указываться различные требования технического характера, нужно воспринимать их именно как примеры выдержек из ТЗ, для лучшего понимания контекста и того, что именно потребуется документировать. Следует заметить, что свои частные требования (например, требования информационной безопасности) формируются в ТЗ или бэклоге для каждого этапа создания сервиса или построения модели ИИ.

Неотъемлемой частью разработки цифрового продукта ИИ является проверка гипотез работоспособности алгоритмов ИИ. Эта проверка выполняется в файлах Jupyter Notebook (JN), требования к которым приведены в соответствующем разделе (следует заметить, что непосредственно файлы JN не встраиваются в исполняемый код – их содержимое экспортируется в него с учётом особенностей используемого целевого языка). Требования к описанию архитектуры и функционированию цифрового продукта ИИ в целом, также вынесены в самостоятельные разделы.

Так как в компании обычно уже имеются свои устоявшиеся стандарты по разработке, оформлению и документированию программных продуктов, выполнение этих требований считается необходимым по умолчанию (например, в Газпром Нефти общие требования к ИТ-безопасности прописаны в ПК-12.02-01 «Политика информационной безопасности»). Поскольку текущий документ посвящён в первую очередь цифровым продуктам, связанным с ИИ, эти общие требования здесь явно не прописываются для облегчения чтения.

Помимо перечисленных в данном файле обязательных требований, программистам, участвующим в разработке цифрового продукта ИИ, также рекомендуется ознакомиться с Единой системой программной документации (ЕСПД). Эта система является комплексом стандартов (ГОСТов) Российской Федерации по оформлению кода и документированию программных продуктов. В этом случае наиболее релевантными являются: ГОСТ 19.101-77 (Виды программ и программных документов), ГОСТ 19.103-77 (Обозначение программ и программных документов), ГОСТ 19.105-78 (Общие требования к программным документам). Следует подчеркнуть, что оформление согласно требованиям ЕСПД по умолчанию не является необходимым (за исключением прямого указания Заказчика на это).

В заключении, следует отметить что техническая документация ПИИ наполняется по мере всего проекта, как только исполняется очередной записанный в ТЗ пункт или выполняется задача в планировщике команды разработки (task tracker). С точки зрения реализации, указанная документация должна являться частью локально сформированной вики-структуры, содержащей всю техническую проектную информацию. Выбор структуры остаётся за Исполнителем (рекомендуется функционал аналогичный проприетарному Confluence), с обязательным требованием возможности выгрузки информации в документы Word и Pdf. Для Газпромнефти, эта база знаний должна быть загружена в корпоративный Confluence.

## 1. Общие требования

### 1.1 Требования к оформлению исходного кода

#### 1.1.1 Формат

Исполнителю требуется предоставлять исходный код в файлах формата используемого языка (например, .py для языка Python). Файлы должны использовать кодировку семейства UTF-8. Имена файлов, директорий и архивов должны иметь ту же кодировку, что и сами текстовые файлы. В качестве управляющих символов для обозначения разрыва строки рекомендуется использовать LF (предпочтительно), либо CRLF.

#### 1.1.2 Модульность

Код должен быть логически разбит на модули и иметь древовидную или иную, допустимую спецификацией языка, структуру импорта модулей. При разбиении исходного кода на модули требуется следовать спецификации или использовать наилучшие практики для данного языка. Рекомендуется использование автоматизированных средств контроля.

#### 1.1.3 Форматирование

Форматирование исходного кода, а именно:

* Использование определенных символов для отступов;
* Формат отступов;
* Оформление блоков кода;
* Именование переменных и модулей;

должно быть выполнено в едином стиле для всего проекта. Смешение стилей не допускается. Рекомендуется следование стандартам языка при наличии таковых (например, PEP8 для Python), а в случае их отсутствия – использовать наилучшие практики для данного языка. В случае предоставления Заказчиком корпоративного стандарта форматирования, нужно использовать именно его. Рекомендуется использование автоматических средств форматирования и/или контроля за его соблюдением. В таком случае к исходному коду также следует приложить соответствующие файлы конфигурации.

## 1.2 Требования к разработке кода

### 1.2.1 Качество кода

Разработка кода должна вестись в соответствии со стандартами языка и принятыми лучшими практиками. Требуется выполнять статический анализ кода, а также проводить его регулярный рефакторинг для улучшения его читаемости и повышения “качества” (подразумеваются не целевые метрики моделей ИИ, а общая оптимальность применяемых методов и классов).

#### 1.2.2 Внутренняя валидация

В разрабатываемом приложении должна обеспечиваться валидация всех входных данных от пользователей, файловых систем, баз данных и внешних систем.

#### 1.2.3 Контроль версий

В ходе разработки цифрового продукта ИИ, работы должны проводиться в закрытом Git-репозитории. Для внутренней команды это будет специализированная платформа ИИ; для подрядчиков – выбор остаётся на их усмотрение с главным требованием отсутствия свободного внешнего доступа к файлам (использование публичных сервисов возможно, но должно явно прописываться в техническом задании). В случае необходимости, Заказчик обеспечивает внешнему Исполнителю доступ к своему закрытому репозиторию для проведения работ. Администрирование ролей в этом случае остаётся за представителями Заказчика, которые выделяют под это человеческий ресурс.

После окончания работ исходный код должен передаваться также в виде Git-репозитория, т.е. помимо прочего содержать файлы системы контроля версий (директория .git и файл .gitignore). Если цифровой продукт ИИ в целевом виде имеет микросервисную архитектуру, исходный код каждого поставляемого сервиса должен храниться в отдельном репозитории в системе контроля версий. Для сжатия должны использоваться формат .zip, либо иной другой, согласованный с Заказчиком. 

#### 1.2.4 Сторонние библиотеки

В случае использования сторонних библиотек, они должны быть включены в состав репозитория в формате файла требований для используемого пакетного менеджера (например, файл requirements.txt для pip). Пакет, содержащий библиотеку, должен быть доступен для скачивания из Интернета. Версия пакета должна быть указана точно (не допускается использование формата “номер версии 1.2 или выше”). Требуется использовать актуальные версии библиотек, не содержащие известных уязвимостей (CVE). Если по какой-то причине используется устаревшая версия библиотек, это должно быть обосновано в пояснениях к коду.

### 1.3 Документирование внутри кода

Документирование исходного кода осуществляется на английском языке в комментариях внутри тела самой программы согласно устоявшимся стандартам и практикам. Настоятельно рекомендуется сразу приводить описание для всех модулей, классов и методов, так как они могут быть запрошены у Исполнителя впоследствии на этапе развития цифрового продукта ИИ. Следует отметить, что документирование малых методов или методов, чье предназначение понятно из названия (например, toInt()) не требуется. 

Помимо документирования указанных элементов кода, в комментариях также должна содержаться информация о способе его форматирования (стандарт языка, лучшие практики или корпоративный стандарт).

## 2. Требования к Jupyter Notebook

Как уже отмечалось, в рамках разработки цифрового продукта ИИ часть работ ведётся в файлах JN, где исследуется применимость различных алгоритмов ИИ для решения поставленной задачи. Эти файлы также надо документировать, поскольку их содержимое является ключевым для верификации работоспособности разрабатываемого продукта. Таким образом, требования, указанные в п. 1, должны соблюдаться при оформлении кода в JN, если не указано иного.

### 2.1 Формат и документирование внутри кода

Необходимо выполнение всех требований, указанных в п. 1.1.1 и п. 1.3, за исключением требования к расширению файла. Все пояснения к ячейкам кода должны быть оформлены с использованием формата Markdown. В случае необходимости в сложных математических выражениях используется LaTeX. Использование HTML допускается в случае, если функциональности Markdown недостаточно, однако не рекомендуется.

### 2.2 Модульность

В файле JN должна прослеживаться чёткая иерархическая структура разбиений на участки, объединенные одной темой, с использованием синтаксиса многоуровневых заголовков Markdown. Каждая ячейка кода должна содержать предшествующее ей объяснение производимых в ней действий (в данном документе, такая пара условно называется “секцией”).

Ячейка кода должна быть небольшого размера. Большие части кода, не взаимодействующие с пользователем (не выводящие информацию) и не являющиеся ключевыми для понимания, должны быть вынесены в функцию в файле исходного кода. Данный файл должен быть подключен как библиотека. Необходимо стремиться к формату, в котором JN представляет собой последовательность вызовов подобных функций. Ячейки должны располагаться последовательно в том порядке, в котором необходимо осуществлять их запуск.

### 2.3 Рекомендуемое оформление секции

Ячейки кода без объяснения к ним допускаются, если содержат интуитивно понятный код размером не более 3 строк. Ячейки кода размером более 15-20 строк рекомендуется дробить на более мелкие секции. На объяснение не накладывается ограничений по объему, однако оно не должно быть излишне подробным.

Если секция выводит некоторую информацию на экран, необходимо убедиться, что данная информация не занимает много места (средний объем должен составлять 5 строк). При передаче файла JN Заказчику требуется удалять всю выводимую секцией информацию, за исключением случая, когда на неё опирается дальнейшее рассуждение.

### 2.4 Рекомендуемая структура JN

Рекомендуется придерживаться следующей структуры файла JN:

* Заголовок, выполненный с использованием синтаксиса Markdown.
* Ячейка кода с директивами imports для подключения внешних библиотек (п. 1.2.4). В пояснении к данной ячейке требуется указать, для чего используется каждая из подключенных библиотек. Для библиотек, входящих в стандартную библиотеку языка, пояснение не требуется. Допускается, но не рекомендуется опускать пояснение для общеизвестных внешних библиотек (например, matplotlib).
* Ячейка, содержащая адреса источников данных. Каждый адрес должен быть вынесен в отдельную глобальную переменную.
* Введение, кратко описывающее назначение файла JN и содержащее справочную информацию и/или ссылки на неё при необходимости.
* Определения. В данном разделе должны быть введены все использующиеся в тексте файла определения, не являющиеся общепринятыми.
* Раздел загрузки данных из источников. В описании должна быть предоставлена информация об источниках и форматах данных. Допускаются ссылки на сопровождающие документы, в том числе Аналитическую Записку. Если имеется возможность, стоит выводить пример загруженных данных для формирования понимания их структуры у читателя. Подобных разделов может быть несколько в составе одного JN.
* Секции с действиями над данными.
* Анализ полученных результатов.
* Любая дополнительная информация.

Пример корректного оформления JN доступен по ссылке: [https://github.com/gazprom-neft/standards].

### 2.5 Работа с данными

По возможности, способ загрузки данных должен быть независим от окружения, в котором запускается файл JN. Крайне не рекомендуется загрузка данных с жесткого диска; если подобная операция все же осуществляется, в описании необходимо указать, какие данные и в каких директориях ожидается найти. В случае, если используется загрузка данных с внешних источников, адреса источников необходимо вынести в глобальные переменные.

Временные данные, генерируемые в процессе работы, требуется хранить либо во временных файлах, либо в директории, непосредственно содержащей JN. Файлы, не используемые при повторных запусках JN, должны очищаться выполнением кода в одной из последних секций.

### 2.6 Оформление графиков

Все графики должны содержать легенду. Оси графиков должны иметь подписи читаемого размера и содержать единицы измерения, где это возможно. Цветовое оформление должно быть достаточно контрастным, чтобы графики легко идентифицировались.

### 2.7 Воспроизводимость результатов работы моделей ИИ

Все результаты, полученные в рамках разработки моделей ИИ, а также преобразования и операции, выполняемые на разных этапах работ, должны быть независимо воспроизводимы внутренними экспертами ГПН при валидации предоставленного Исполнителем цифрового решения. К таким операциям и результатам относятся:

1. Выгрузка из источников и подготовка датасетов, включая сшивку, фильтрацию, балансировку, разбиение на выборки и т.п.;
1. Исследование применимости моделей ИИ, включая их непосредственное построение, подбор гиперпараметров и архитектуры;
1. Сравнение результатов моделей согласно выбранным метрикам;
1. Исследование границ применимости моделей;
1. Любые другие действия, являющиеся ключевыми для понимания принципов действия моделей ИИ.

Помимо, непосредственной проверки грамотности решения это необходимо для:

1. Демонстрации работоспособности решения (запуск, расчёты, вывод результатов) на различных вычислительных машинах (персональные компьютеры, рабочие станции, серверы) и в разных средах (локально и в облаке);
1. Демонстрации устойчивости полученного решения, подразумевающей, что при повторном запуске будут получаться те же самые результаты;
1. Верификации достаточности требований, сформулированных Исполнителем, для успешной работы модели; например, это могут быть требования доступов к источнику данных, откуда выгружается датасет, или требования наличия определённых библиотек, содержащих шаблоны моделей ИИ;
1. Обеспечения прозрачности решения с точки зрения достижения именно результатов, заявленных в техническом задании или бэклоге;
1. Обеспечения прозрачности решения с точки зрения информационной безопасности, в частности, отсутствия посторонних запросов или выгрузок, не предусмотренных в данной работе;
1. Обеспечения уверенности в результатах полученного решения в случае, когда они будут поступать на вход в следующий процесс или использоваться в другой модели (например, последовательное решение задачи прогнозирования и оптимизации);
1. Получения практического опыта, необходимого внутренней команде ГПН для поддержки, доработки и тиражирования представленного решения; к этому также относится использование отдельных логических блоков кода решения в других задачах;
1. Дополнительной возможности, отыскать ошибки в коде.

Для обеспечения воспроизводимости моделей ИИ и проверки результатов внутренними экспертами ГПН, Исполнитель должен предоставить:

1. Подробную инструкцию (методологию) сборки и запуска скриптов отвечающих, за соответствующий этап работ (например, подключение к источнику данных или подбор гиперпараметров модели); эта инструкция должна содержать все требования по вычислительным ресурсам и спецификациям системы, где предполагается тестировать модель;
1. Архив файлов в виде Git-репозитория, содержащий все необходимые инструкции, исходные данные, скрипты и библиотеки; если какие-то библиотеки являются общедоступными и не содержаться в изначальном архиве, требуется дать ссылку на соответствующий проверенный репозиторий в сети интернет (например, это может быть репозиторий непосредственных разработчиков этой библиотеки);
1. Описанный набор тестовых сценариев для проверки базовой функциональности решения; например, это могут быть служебные запросы, выполняемые в рамках отладки (дебаггинга) или поочерёдный запуск всех блоков кода;
1. Хорошо структурированную систему контроля версий, которая бы обеспечивала подсветку новых или изменённых блоков кода (это относится как к моделям, так и к датасетам); хорошей практикой будет использование максимально наглядного стандарта наименований файлов в Git-репозитории, который бы также отражал необходимую последовательность запуска скриптов;
1. Актуальную версию всего исполняемого кода, соответствующую всем отчётным и презентационным материалам; хорошей практикой будет обеспечение автоматической синхронизации архива с проверяемым кодом, направляемым на экспертов, и архива с рабочим кодом, над которым в данный момент трудится Исполнитель.

Наконец, в контексте исследования моделей и обоснования результатов представленного решения, Исполнителю также нужно обращать внимание на следующие факторы:

1. Проведение всех исследований должно выстраиваться по единой методологии для корректности сравнения результатов; желательно согласовывать план экспериментов заранее;
1. Представленные результаты должны быть статистически значимы; например, выборки должны содержать достаточное количество объектов, объекты должны быть равномерно перемешаны и сбалансированы и т.п.; все ограничения и допущения нужно явно указывать;
1. Обеспечено отсутствие конфликта интересов и предвзятости в исследованиях, когда Исполнитель неосознанно подгоняет результаты к заранее принятой гипотезе (тем не менее, полностью обезличенные и лишённые физического смысла данные также использовать не стоит, так как это может привести к потере времени на анализ заведомо ложных корреляций);
1. Должны документироваться также отрицательные результаты, чтобы впоследствии не тратить время на повторную проверку гипотез, которые уже до этого проверялись и доказали свою неэффективность.

### 2.8 Предоставление файлов в формате исходного кода

Всю функциональность, реализованную в файлах JN, требуется перенести в файлы исходного кода в формате используемого языка (п. 1.1.1). При этом функциональность программ в обоих типах файлов должна отличаться минимально (исключая промежуточный вывод). Следует подчеркнуть, что предоставляются и исполняемый код, и файлы JN. Первый используется для разработчиков, ответственных за написание интерфейсов цифрового продукта ИИ и его интеграцию в информационный контур компании. Второй нужен дата-саентисту для валидации предоставленного решения.

## 3. Требования к архитектуре цифрового продукта ИИ

### 3.1 Архитектура приложения

Приложение должно быть разработано для выполнения в среде ОС Linux.

#### 3.1.1 Модульность

Архитектурно приложение должно представлять собой один или несколько сервисов, общающихся согласно требованиям REST. Разбиение на сервисы, если таковое имеется, должно быть логичным. Требуется минимизировать связи между сервисами приложения, насколько это возможно.

Сервисы, работоспособность которых зависит друг от друга, должны быть объединены в один.
Процесс сервиса не должен требовать привилегий суперпользователя, сетевых портов, номера которых менее 1024, а также читать или записывать информацию из файлов, доступных только для суперпользователя.

Каждый сервис должен корректно обрабатывать сигналы операционной системы, в частности при получении сигнала SIGTERM сервис должен остановить обработку запросов и корректно завершить работу настолько быстро, насколько это возможно.

Сервисы приложения не должны хранить во внутренней памяти данные, значимость которых выходит за пределы обработки одного запроса. Для хранения подобных данных должны использоваться внешние сервисы хранения данных. Таким образом, приложение должно реализовывать stateless архитектуру.

Архитектура приложения должна предполагать возможность запуска нескольких экземпляров приложения/сервисов на одной или нескольких машинах.

#### 3.1.2 Актуальность

Не допускается использование версий программного обеспечения, библиотек, стандартов, помеченных на момент начала проекта как “устаревшие (outdated)” и “осуждается (deprecated)”, с имеющимся сроком вывода технологии из обращения (например, версия 2 языка Python), помимо исключительных случаев, требующих обоснования. Программное обеспечение, библиотеки, стандарты, получившие данные статусы в процессе работы над проектом допускаются, однако по возможности должны быть заменены на актуальные версии.

#### 3.1.3 Использование инструментов оркестрации

Подход к построению инфраструктуры должен быть един для всех проектов – должны использоваться одинаковые интерфейсы, протоколы, имена, онтологии сервисов и принципы, для обеспечения последующей информационной совместимости. Конкретные шаблоны предоставляются представителями Заказчика в рамках технического задания. Ниже приведён пример для инструментов оркестрации.

Если согласовано использование инструмента оркестрации, рекомендуется:

* Реализовать механизм service discovery;
* Обеспечить возможность горизонтального масштабирования приложения (составляющих его сервисов);
* Использовать механизм автоматизации обновления конфигураций компонентов инфраструктуры;
* Выполнить интеграцию с Jenkins для обеспечения процессов CI/CD;
* Реализовать механизмы обеспечения высокой доступности и отказоустойчивости сервисов;
* Реализовать механизмы балансировки нагрузки;
* Реализовать механизмы централизованного управления привилегиями контейнеров;
* Обеспечить возможность выборочного обновления реплик сервисов для проведения продуктивного тестирования новых релизов;
* Обеспечить возможность гибкого перехода сервисов на предыдущий/последующий релиз;
* Обеспечить механизм RBAC (role-based access control) для разграничения доступа к ресурсам и объектам;
* Обеспечить наличие мультитенантности и полноценной изоляции ресурсов между тенантами/проектами (хранилище, сеть);
* Взаимодействие каждого компонента и сервиса должно происходить с идентификацией и авторизацией при помощи сертификатов по TLS (TLS Bootstrapping);
* Обеспечить наличие механизма централизованного управления квотами и лимитами (для проектов, не только для контейнеров и подов);
* Обеспечить передачу журналов (логов) в централизованную систему сбора событий (ArcSight);
* Обеспечить наличие механизма подписания образов и запуска их на определенных узлах;
* Обеспечить механизм аутентификации;
* Обеспечить наличие средств маршрутизации входящего (Ingress) и исходящего (Egress) трафика для контейнеров;
* Обеспечить наличие механизма управления сетевыми политиками.

### 3.2 Внешние сервисы

Приложение, использующее внешние сервисы (базы данных, открытые API, и т.д.) должно получать секреты (строки соединения) из внешнего защищенного хранилища. В случае, если приложение нуждается к доступу в Интернет, оно должно поддерживать возможность использования прокси-сервера. Запрещается использовать сервисы, находящиеся в сети Интернет для хранения или обработки любых данных, кроме специально согласованных случаев.

Если приложение нуждается для своей работы в сторонних компонентах (базах данных, службах синхронизации, брокерах сообщений), требуется указание поддерживаемых систем и их версий. Способы доступа к сторонним компонентам должны быть конфигурируемыми (п. 4.2).

В качестве методических указаний по обеспечению кибер-безопасности (включая вопросы передачи данных и использованию внешних программных компонентов) требуется руководствоваться принятым внутрикорпоративным регламентом.

### 3.3 Логирование

Предоставляемое программное обеспечение должно иметь единый документированный формат логов. Также должна иметься документация, описывающая способы доступа к логам, в том числе в реальном времени. Приветствуется поддержка нескольких драйверов логирования в случае использования Docker-контейнеризации.

Для автоматизации развертывания компонентов продукта рекомендуется реализовать две проверки работоспособности компонента, которые OpenShift Origin (OKD) использует при развертывании и в процессе работы компонента:

* Liveness Probe – периодическая проверка работоспособности, если проверка не выполняется, то контейнер будет перезапущен. Проверка должна проходить быстро и в процессе выполнения опрашивать доступность необходимых ресурсов;
* Readiness Probe –  определяет, можно ли направлять трафик на контейнер. Например, контейнер может быть запущен, но еще не готов обслуживать запросы пользователей;

Логи должны выводиться в stdout/stderr для совместимости со сборщиком логов платформы. Уровень логирования для каждого компонента должен изменяться без необходимости пересборки программного обеспечения (ПО). Сбор метрик работы компонент приложения рекомендуется реализовать с помощью стандартного HTTP endpoint/metrics, и применения сервиса мониторинга Prometheus.

## 4. Сборка и запуск

### 4.1 Автоматизация сборки программного обеспечения

ПО, предоставляемое Исполнителем (внутренним или внешним), должно поддерживать систему автоматической сборки и иметь в своём составе все требуемые файлы конфигурации. Сборка может включать в себя создание как единого исполняемого файла, так и многих компонент ПО. В обоих случаях требуется предоставить как скрипты сборки с документацией к ним, так и инструкцию по сборке, установке и запуску. Предоставление компонент ПО в бинарном виде не допускается (исключение – сторонние библиотеки в скомпилированном виде, неизменность которых может быть проверена). Далее в тексте, ПО (либо набор программных компонент, из которых оно состоит), полученное при выполнении сборочных скриптов, условно называется “артефактом”.

#### 4.1.1 С использованием контейнеризации

С Исполнителем может быть согласовано использование контейнеризации. В таком случае он должен предоставить:

* Список используемых сторонних библиотек или способов их сборки.
* Пример Docker-файла, при сборке которого (docker build) может быть получен докер-образ для создания докер-контейнера на его основе.
* Манифесты к Dockerfile, позволяющие развернуть сервис в OKD. Допускается использование встроенного механизма шаблонизации OKD.
* Обоснование использования библиотек, либо ПО, которые дополнительно устанавливаются при сборке докер-образа.
* Обоснование осуществления сборки именно в указанном порядке и использования выбранного базового образа.

При сборке контейнера необходимо использовать доверенные базовые образы:

* Red Hat Universal Base Image;
* RHEL Atomic Base Image;
* RHEL Minimal Base Image;
* RHEL Base Image.

В Dockerfile команды пакетного менеджера должны использоваться в одной инструкции RUN с удалением его кеша. Для устанавливаемых пакетов, версии рекомендуется определять явным образом (использование версии по умолчанию нежелательно).

Необходимо исключить полномочия setuid и setgid в образе контейнера. Не допускается использование команды ADD в Dockerfile (вместо нее необходимо использовать COPY). Не допускается отключать политику мандатного разграничения доступа в контейнере (AppArmor profile или SELinux security options). Не допускается использовать (share) следующие сущности хостовых машин в контейнере:

* network namespaces;
* process namespaces;
* IPC namespaces;
* UTS namespaces;
* user's namespaces.

Образ контейнера должен содержать актуальные версии операционных систем и приложений, не имеющие известных уязвимостей (CVE). Dockerfile должен поддерживать указание URL для пакетного менеджера, используемого в приложении.

Состав пакетов в образе контейнера должен быть минимально достаточен для работы. Неиспользуемые в ходе работы контейнеризированного приложения пакеты должны отсутствовать в образе контейнера. Не допускается хранить секреты в Dockerfile. Не допускается работа с SSH внутри контейнеров.

#### 4.1.2 Без использования контейнеризации

В случае, если использование контейнеризации не согласовано, требуется предоставить скрипты сборки (либо конфигурационные файлы сборочных утилит), выполнив которые можно получить артефакт в одном из поддерживаемых форматов пакетов для совместимых ОС (.rpm, .deb). Формат пакета должен быть согласован заранее, однако, если этого не произошло, формат остаётся на выбор Исполнителя.

В остальном настоятельно рекомендуется следовать описанным в п. 4.1.1 правилам, если таковые применимы.

### 4.2 Конфигурация

Конфигурация ПО должна осуществляться единым (по возможности, согласованным заранее) способом. Допускается использование нескольких конфигурационных файлов одного формата. Приветствуется возможность построения иерархии конфигурационных файлов, если таковая функциональность поддерживается спецификацией формата.

Для конфигурационных файлов рекомендуется использование человекочитаемого формата (например, .xml, .json, .yaml, формат .ini, ключ-значение).

Запрещается хранить любые секреты (данные аутентификации, приватные ключи и т.д.) в образе контейнера, в конфигурационных файлах и переменных окружения. Перечень секретов явно документируется и хранится в распределенном защищённом хранилище секретов. Используемые параметры и варианты их значений должны быть подробно документированы.

### 4.3 Запуск

Процесс запуска должен быть полностью документирован. Возможно использование скриптов, осуществляющих запуск ПО. Приложения, работающие в формате daemon должны иметь systemd-совместимый интерфейс.

Требуется указание минимальных и рекомендуемых системных требований для запуска приложений. Если запуск производится в контейнере, необходимо использовать минимально достаточный перечень сетевых портов. Сетевые порты, не требуемые для корректной работы контейнера, не должны быть доступны.

### 4.4 Авторизация пользователей

Если для работы с ПО требуется предварительная авторизация с использованием персональных данных человека (например, необходимо заполнить шаблонную форму с указанием своих реквизитов для доступа к системе), при первом запуске должно быть предусмотрено подписание пользовательского соглашения о согласии на их обработку и хранение. Дополнительно, должно быть предусмотрено соглашение о неразглашении, в рамках которого пользователь обязуется не использовать это ПО для несанкционированного экспорта конфиденциальных данных (например, технологических режимов работы оборудования или финансовой информации). Наконец, в случае продолжительного отсутствия пользовательской активности, ПО должно автоматически выгружать авторизированного пользователя из приложения.

## 5. Документирование

Подготовка исчерпывающего пакета технической и пользовательской документации для цифрового продукта ИИ является достаточно трудоёмким и длительным процессом, являющимся дополнительной статьёй в смете расходов. По этой причине, глубина, объём и сроки подготовки такой документации должны явным образом прописываться в ТЗ на разработку или в договоре сервисной поддержки после сдачи продукта в эксплуатацию. Ниже приводится, пример документации, которая может быть запрошена Заказчиком в рамках типового контракта на разработку цифрового продукта ИИ. Важно отметить что исчерпывающий список документов для ГПН содержится во Временном техническом регламенте Цифрового Проекта, в который следует обращаться по всем спорным вопросам (технический регламент имеет приоритет над данным документом).

Обычно, минимальная документация специфичная для цифрового продукта ИИ включает:

* Документацию ко всем используемым модулям;
* Документацию ко всем открытым API, если к таковым не существует формализованного и документированного стандарта;
* Документацию к решениям в коде, которые используют редкие или узкоспециализированные алгоритмы или библиотеки, а также нетривиальные методы (комментарии в коде с описанием решения и его обоснованием).

При составлении документации рекомендуется пользоваться следующим правилом, определяющим подробность документирования: человек, не имеющий опыта работы с используемым ПО, однако обладающий опытом с аналогичным по функционалу цифровым сервисом, должен быть в состоянии сразу приступить к работе с данным ПО. Ссылки на конкретные аналоги используемого ПО запрещены.

Как уже отмечалось, документация должна являться как частью программного кода (документация к функциям, классам, модулям), так и быть собрана в некоторой единой базе знаний вики (документация к конфигурационным файлам, способам сборки, запуска и остановки приложения). Вики должна быть либо частью проекта (отдельный файл, набор файлов, специальная система генерации и хранения документации), либо быть доступной из Интернета в течение продолжительного времени.

### 5.1 Техническое описание решения

Требуется предоставить техническое описание ПО, которое должно включать в себя следующее:

* Состав ПО (архитектурные компоненты, хранилища данных, внешние сервисы, и т.д.);
* Функциональность ПО (в том числе user stories); эта информация обычно содержится в ТЗ;
* Назначение ПО (допускаются ссылки на техническое задание к ПО);
* Интерфейсы и интеграции;
* Технические лимиты, системные требования;
* Ограничения эксплуатации;
* Прочие уникальные особенности.

### 5.2 Описание архитектуры решения

Архитектура решения должна быть документирована в формате “от общего к частному”. Первоначально должно даваться общее описание цифрового решения, проблем, которые она призвана разрешить, способов использования и общей информации по настройке. Затем должен производиться подробный разбор каждого компонента решения в том же формате. Минимальной единицей, подлежащей документированию, в данном случае является модуль цифрового решения. Взаимодействие и зоны ответственности отдельных компонент можно реализовать, например, в виде диаграмм и/или рисунков в формате UML. Повторно, для исчерпывающей информации по полному списку документов и их наполнению рекомендуется обращаться ко Временному техническому регламенту Цифрового Проекта.

Обычно описание архитектуры решения включает:

* Диаграмму взаимодействия модулей и компонент;
* Общую пояснительную записку (например, в формате ЕСПД);
* Документацию к способам сборки и запуска приложения;
* Документацию по сервисной поддержке приложения;
* Руководство пользователя;
* Документацию ко всем используемым форматам конфигурирования и логирования;
* Описание потоков данных;
* Описание форматов и способов хранения и передачи данных;
* Список ресурсов сети Интернет, взаимодействие с которыми требуется для корректной работы приложения, а также обоснование их выбора (требуется указать соответствующие URL и API).

### 5.3 Документирование конфигурационных опций

Для каждого документируемого параметра требуется, как минимум, указать:

* Название параметра;
* Область решения, за которую он отвечает;
* Список поддерживаемых значений;
* Тип(ы) поддерживаемых значений;
* Обязательный/нет;
* Рекомендованное значение или значение по умолчанию (если применимо);
* Конфликты с другими параметрами (если применимо).

### 5.4 Документирование сборочных скриптов

Требуется документирование всех этапов сборки. Неочевидные действия должны быть расписаны дополнительно. Требуется общее описание процесса для его повторения без использования предоставленных Исполнителем скриптов. Требуется указать краткий перечень проблем, которые возникали в процессе разработки, и пути их решения.

### 5.5 Документирование процесса запуска

Процесс запуска должен быть документирован как последовательность шагов. Аналогично процессу сборки, требуется указать краткий перечень возможных проблем и пути их решения.

### 5.6 Форматы документирования

Для документирования исходных кодов рекомендуется использование автоматических средств генерации документации в едином формате. Для описаний API, взаимодействий и данных рекомендуется использовать предназначенные для этого форматы. Для вики и документации, не поддающейся строгому форматированию, рекомендуется использование форматов .html, .md, .pdf.
